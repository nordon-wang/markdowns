根据生成的bundle.js可以梳理webpack的整体打包思路，就是利用一个自执行函数创建一个闭包，在这个独立的作用域中，将模块的路径作为modules的键、模块的内容放在一个函数中作为值作为自执行函数的形参传递进来，通过自定义的函数 __webpack_require__进行递归解析。

简单分析一下bundle的整体执行过程

1. 第一步: 自执行函数第一次执行时，会直接运行内部的__webpack_require__函数，并将入口文件的路径./src/index.js作为形参moduleId传递
2. 第二步: 在函数__webpack_require__执行过程中 

1. 会首先判断当前moduleId是否已经存在缓存installedModules中，若是存在则直接返回，不需要再继续解析其依赖。若是不存在，则会构造一个对象并将其同时存installedModules中和module中。第一次执行时installedModules为空对象，moduleId为./src/index.js。

1. 执行modules[moduleId]函数，即执行modules['./src/index.js']，会通过call改变其作用域并传递module, module.exports, __webpack_require__三个形参，执行的内容就是入口文件模块./src/index.js中的JS代码。 

1. call传递的作用域置为module.exports，由于module.exports此时为空对象，则index.js中的作用域就是指向它，这也是典型的使用闭包来解决作用域的问题。
2. module, module.exports的作用就是用于模块内抛出对象使用的，作用是一个的，可以参考require.js进行这块的理解

1. __webpack_require__的作用就很巧妙了，此时入口index.js中使用的require('./parent.js')已经被替换成__webpack_require__("./src/parent.js\"),执行modules[moduleId]函数时便会在此调用__webpack_require__函数进行递归调用，会再次回到第二步，直到child.js执行完毕，整个bundle才算执行结束。

分析完bundle之后，会发现对于webpack的打包结果，除了形参modules会跟着代码的业务逻辑修改而变化之外，自执行函数中的代码始终是固定不变的，因此想要编写一个属于自己的webpack时，重点关注和需要解决的就是modules这个对象是如何生成的。