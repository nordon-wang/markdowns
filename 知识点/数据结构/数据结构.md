## 数据结构

### 栈

栈是一种特殊的线性表,仅能够在栈顶进行操作,有着先进后出、后进先出的特性

#### 实现

```javascript
class Stack {
    #stackArr = [] // 私有属性
    constructor() {
        // 不建议直接在此定义stackArr, 因为stackArr只能通过暴露的方法进行操作, 不能让实例可以直接操作stackArr
        // this.stackArr = []
    }
    
    // push 添加一个元素到栈顶
    push(item) {
        this.stackArr.push(item)
    }
    
    // pop 弹出栈顶元素
    pop() {
        return this.stackArr.pop()
    }
    
    // top 返回栈顶元素, 取值操作
    top() {
        return this.stackArr[this.stackArr.length - 1]
    }
    
    // isEmpty 判断栈是否为空
    isEmpty() {
        return this.stackArr.length === 0
    }
    
    // size 返回栈里面元素个数
    size() {
        return this.stackArr.length
    }
    
    // clear 清空栈 重置
    clear() {
         this.stackArr = []
    }
}
```

栈的实现其实就是基于数组的封装,既然已经有了数组,为何还需要再封装一层实现栈呢?

1. 数组提供了很多的操作方式,可以很方便的对于数据进行任意操作,其实是不可控的,基于数据封装一层栈结构,可以很好限制对数据的任意操作,只能遵从栈的操作特性(先进后出,后进先出),为实际业务开发中提供一种思考问题的方式
2. 基于数组封装栈,是为了隐藏是实现细节,当我们遇到业务和开发问题时,站在栈的肩膀思考问题会来的更方便一些,而不是使用数组一把梭

#### 应用

#### 判断括号合法

```javascript
let str1 = 'a(daj(fl(ks)aj)fl)kas' // 合法
let str2 = 'as(dj(flkajs)d(fsaj)fs)' // 合法
let str3 = 'as(dfl)ka(sf)j(skd)f)' //  不合法, 缺少
let str4 = 'asd(kl)alk)s(df' // 不合法 顺序不对
```

思路

循环字符串,针对不同类型的字符串做不同的操作

遇到左括号 - 压栈

遇到右括号 - 判断栈是否为空,若是为空则说明没有对应的左括号,不合法,栈不为空则弹栈,抵消掉一对括号

其他类型 - 跳过

当遍历完之后,若是栈为空, 则合法,否则就是不合法的

```javascript
const STR1 = 'a(daj(fl(ks)aj)fl)kas' // 合法
const STR2 = 'as(dj(flkajs)d(fsaj)fs)' // 合法
const STR3 = 'as(dfl)ka(sf)j(skd)f)' //  不合法, 缺少
const STR4 = 'asd(kl)alk)s(df' // 不合法 顺序不对

/** 
 * 判断字符串中的括号是否合法
*/
const isLegalBracket = str => {
  if (Object.prototype.toString.call(str) !== "[object String]") {
    // throw new Error('str is must string');
    return false;
  }
    
  const STACK = new Stack()

  for (let i = 0; i < str.length; i++) {
    const ELE = str[i]
    
    if (ELE === '(') { // 压栈
      STACK.push(ELE)
    }else if(ELE === ')') { 
      if (STACK.isEmpty()) { // 栈为空则说明没有对应的左括号,不合法
        return false
      } else { // 弹栈
        STACK.pop()
      }
    }
  }

  return STACK.isEmpty()
}

console.log(isLegalBracket(STR1)) // true
console.log(isLegalBracket(STR2)) // true
console.log(isLegalBracket(STR3)) // false
console.log(isLegalBracket(STR4)) // false
```

#### 计算逆波兰表达式

> 用途
>
> 逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)*(c+d)转换为ab+cd+* 
>
> 优势
>
> 它的优势在于只用两种简单操作，入栈和出栈就可以搞定任何普通表达式的运算。其运算方式如下：
>
> 如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。

参照表

| 正常的表达式(中缀表达式) | 逆波兰表达式(后缀表达式) |
| ------------------------ | ------------------------ |
| a + b                    | [a, b, +]                |
| a + (b - c)              | [a, b, c, -, +]          |
| a + (b - c) * d          | [a, b, c, -, *, +]       |
| a * (b + c) + d          | [a, b, c, +, *, d, +]    |

计算 `['1', '2', '3', '+', '*', '4', '+']`等价于计算`1 * (2 + 3) + 4`

解题思路:

将数组依次遍历,当遇到非运算符时,将数据进行压栈处理,将当遇到预算符时,从栈中连续弹栈两次进行然后与运算符结合计算,并且将结果压栈,当循环结束之后,栈中只剩下一个数据,便是结果

```javascript
const ARR = ['1', '2', '3', '+', '*', '4', '+']

const reversePolishNotation = arr => {
  // 容错处理
  if(!Array.isArray(arr)) {
    throw new Error('arguments is must array');
  }

  const STACK = new Stack()
  const OPERATORS = ['+', '-', '*', '/', '']

  for (let i = 0; i < arr.length; i++) {
    const ELE = arr[i]

    if(OPERATORS.includes(ELE)){ // 操作符
      // 1. 连续弹栈两次
      const A = STACK.pop()
      const B = STACK.pop()

      // 2. 将数据与运算符拼接
      const STR =  B + ELE + A

      // 3. 执行运算并将结果压栈
      const RES = parseInt(eval(STR)).toString()
      STACK.push(RES)
    }else { // 非操作符 直接压栈
      STACK.push(ELE)
    }
  }

  return STACK.top()
}

console.log(reversePolishNotation(ARR)); // 9
```



### 队列

队列是一种特殊的线性表,它只允许再队列的头部删除元素,在队列的尾部添加新的元素,特性先进先出,后进后出

#### 实现

```javascript
class Queue {
  constructor() {
    this.queue = []
  }

  // 队列尾部添加元素
  enqueue(queue) {
    this.queue.push(queue)
  }

  // 队列头部删除元素
  dequeue() {
    return this.queue.unshift()
  }

  // 查看队列头部元素 不操作队列 仅仅查看
  header() {
    return this.dequeue[0]
  }
    
  // 查看队列尾部元素 不操作队列 仅仅查看
  tail() {
    return this.queue[this.queue.length - 1]
  }

  // 返回队列大小
  size() {
    return this.queue.length
  }

  // 清楚队列
  clear() {
    this.queue.length = []
  }

  // 是否为空队列
  isEmpty() {
    return this.queue.length === 0
  }
}
```

#### 应用

#### 约瑟夫环



#### 斐波那契





























